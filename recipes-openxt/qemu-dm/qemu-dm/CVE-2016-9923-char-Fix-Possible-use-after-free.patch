###############################################################################
SHORT DESCRIPTION:
###############################################################################
QEMU: char: Fix Possible use-after-free (CVE-2016-9923)
CVE-2016-9923

###############################################################################
LONG DESCRIPTION:
###############################################################################
From: Jason Andryuk <jandryuk@gmail.com>
Subject: char: Fix Possible use-after-free (CVE-2016-9923)

From the CVE:
Quick Emulator (Qemu) built with the 'chardev' backend support is
vulnerable to a use after free issue. It could occur while hotplug and
unplugging the device in the guest. A guest user/process could use this
flaw to crash a Qemu process on the host resulting in DoS.

The upstream fix incorporates other code changes, but the relevant
portion is pointed out by Paolo Bonzini in this email:

https://lists.gnu.org/archive/html/qemu-devel/2016-10/msg05597.html

Upstream commit a4afa548fc6dd9842ed86639b4d37d4d1c4ad480

The upstream commit also mentions
    Also a mux CharDriver should go through mux->backends[focused], since
    chr->be will stay NULL. Before that, it was possible to call
    chr->handler by mistake with surprising results, for ex through
    qemu_chr_be_can_write(), which would result in calling the last set
    handler front end, not the one with focus.

This is not fixed.

Signed-off-by: Jason Andryuk <jandryuk@gmail.com>

CVE-2016-9923

###############################################################################
PATCHES:
###############################################################################
diff --git a/qemu-char.c b/qemu-char.c
index 7627719..b1e28c0 100644
--- a/qemu-char.c
+++ b/qemu-char.c
@@ -4761,6 +4761,17 @@ out_error:
     return NULL;
 }
 
+static bool qemu_chr_is_busy(CharDriverState *chr)
+{
+    if (chr->is_mux) {
+        MuxDriver *d = chr->opaque;
+        return d->mux_cnt >= 0;
+    } else {
+        return (chr->chr_can_read || chr->chr_read ||
+                chr->chr_event || chr->handler_opaque);
+    }
+}
+
 void qmp_chardev_remove(const char *id, Error **errp)
 {
     CharDriverState *chr;
@@ -4770,8 +4781,7 @@ void qmp_chardev_remove(const char *id, Error **errp)
         error_setg(errp, "Chardev '%s' not found", id);
         return;
     }
-    if (chr->chr_can_read || chr->chr_read ||
-        chr->chr_event || chr->handler_opaque) {
+    if (qemu_chr_is_busy(chr)) {
         error_setg(errp, "Chardev '%s' is busy", id);
         return;
     }
-- 
2.9.4

